lexer grammar HelloLexer;
HI : 'H' 'i'
ID : [a-z]+;
WS : [\t\n\r\s]+ -> skip;

grammar Name
这是词法跟语法都在同一个文件声明的写法，称之为combined。若要分开，可以使用lexer grammar Name和parser grammar Name。


Lexer定义词法分析规则；
Parser 定义语法分析规则；
Tree用于遍历语法分析树；
Combine既可以定义语法分析规则，也可定义词法分析规则，规则名称遵循上述规则；
Import 用于导入语法规则。使用Import语法规则分类，可以使语法规则更加清晰；并且可以采用面向对象的思想设计规则文件，使其具有多态及继承的思想。值得注意的是，当前规则的优先级高于导入规则。

ANTLR规则基于BNF范式，用’|’表示分支选项，’*’表示匹配前一个匹配项0次或者多次，’+’ 表示匹配前一个匹配项至少一次。

NUM:[0-9]+;


规则的名称是NUM，以大写字母开头，因此是词法分析的规则；规则的内容是[0-9]+，表示所有的整数。



与之前的SQL解析原理相同，ANTLR的词法解析同样是将SQL拆分为词法单元。
ANTLR解析词法规则时，并不理解规则的具体含义，
不清楚哪些规则是关键字定义，哪些规则是标识符定义，它会根据读取顺序为每个规则编号，编号靠前的规则将优先匹配，
匹配成功则直接返回该词法单元。在设计词法拆分规则时，需要将标识符规则放置在关键字规则之后，确保关键字匹配失败后，再去匹配标识符。



ANTLR采用状态转换表实现字符的匹配。它将词法拆分规则转换为表格，每次读取一个字符，根据当前字符类型及当前状态查询该表，并判断读入字符是否匹配规则。如果规则匹配，则接受该字符，并继续读取下个字符；
如果规则不匹配，则拒绝接受该字符。此时，若当前状态是成功匹配某一词法单元的可接受状态，则返回该词法单元；反之则提示错误。以此类推，如果接受该字符，则继续读取下一字符。
直至成功返回一个词法单元或匹配失败提示错误。


首先确定好我们要做的事，开始写语法文件：
grammar SomeLanguage; // 声明语法头
/*
*========================
*   一些 options 配置
    *=======================
    */
    options {
    language = Java; //设定生成代码的语言
    }
    
